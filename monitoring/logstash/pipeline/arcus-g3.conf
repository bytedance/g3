input {
  beats {
    port => 5044
  }
  
  tcp {
    port => 5000
    codec => json_lines
  }
  
  udp {
    port => 5000
    codec => json_lines
  }
}

filter {
  # Parse G3Proxy logs
  if [fields][service] == "g3proxy" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:component} %{GREEDYDATA:message}" }
    }
    
    date {
      match => [ "timestamp", "ISO8601" ]
    }
    
    mutate {
      add_field => { "service_type" => "proxy" }
    }
  }
  
  # Parse G3StatsD logs
  if [fields][service] == "g3statsd" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:component} %{GREEDYDATA:message}" }
    }
    
    date {
      match => [ "timestamp", "ISO8601" ]
    }
    
    mutate {
      add_field => { "service_type" => "metrics" }
    }
  }
  
  # Parse Arcus-G3 logs
  if [fields][service] == "arcus-g3" {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{DATA:component} %{GREEDYDATA:message}" }
    }
    
    date {
      match => [ "timestamp", "ISO8601" ]
    }
    
    mutate {
      add_field => { "service_type" => "swg" }
    }
  }
  
  # Parse tenant information
  if [tenant_id] {
    mutate {
      add_field => { "tenant_context" => "%{tenant_id}" }
    }
  }
  
  # Parse user information
  if [user_id] {
    mutate {
      add_field => { "user_context" => "%{user_id}" }
    }
  }
  
  # Parse request information
  if [request_id] {
    mutate {
      add_field => { "request_context" => "%{request_id}" }
    }
  }
  
  # Parse security events
  if [event_type] == "security" {
    mutate {
      add_field => { "security_event" => true }
    }
  }
  
  # Parse audit events
  if [event_type] == "audit" {
    mutate {
      add_field => { "audit_event" => true }
    }
  }
  
  # Parse performance events
  if [event_type] == "performance" {
    mutate {
      add_field => { "performance_event" => true }
    }
  }
  
  # Parse error events
  if [level] == "ERROR" or [level] == "FATAL" {
    mutate {
      add_field => { "error_event" => true }
    }
  }
  
  # Parse warning events
  if [level] == "WARN" {
    mutate {
      add_field => { "warning_event" => true }
    }
  }
  
  # Parse HTTP status codes
  if [http_status] {
    if [http_status] >= 200 and [http_status] < 300 {
      mutate {
        add_field => { "http_status_class" => "2xx" }
      }
    } else if [http_status] >= 300 and [http_status] < 400 {
      mutate {
        add_field => { "http_status_class" => "3xx" }
      }
    } else if [http_status] >= 400 and [http_status] < 500 {
      mutate {
        add_field => { "http_status_class" => "4xx" }
      }
    } else if [http_status] >= 500 {
      mutate {
        add_field => { "http_status_class" => "5xx" }
      }
    }
  }
  
  # Parse response times
  if [response_time] {
    mutate {
      convert => { "response_time" => "float" }
    }
    
    if [response_time] < 0.1 {
      mutate {
        add_field => { "response_time_class" => "fast" }
      }
    } else if [response_time] < 1.0 {
      mutate {
        add_field => { "response_time_class" => "normal" }
      }
    } else {
      mutate {
        add_field => { "response_time_class" => "slow" }
      }
    }
  }
  
  # Parse IP addresses
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
  
  # Parse user agents
  if [user_agent] {
    useragent {
      source => "user_agent"
      target => "ua"
    }
  }
  
  # Parse URLs
  if [url] {
    urldecode {
      field => "url"
    }
  }
  
  # Parse domains
  if [domain] {
    mutate {
      add_field => { "domain_tld" => "%{domain}" }
    }
    
    grok {
      match => { "domain_tld" => "%{WORD:domain_name}\.%{WORD:domain_tld}" }
    }
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "arcus-g3-logs-%{+YYYY.MM.dd}"
    template_name => "arcus-g3-logs"
    template => "/usr/share/logstash/templates/arcus-g3-logs.json"
    template_overwrite => true
  }
  
  # Send to stdout for debugging
  stdout {
    codec => rubydebug
  }
}
